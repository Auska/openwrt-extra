--- a/src/chinadns.c
+++ b/src/chinadns.c
@@ -50,12 +50,18 @@ typedef struct {
 
 // avoid malloc and free
 #define BUF_SIZE 2048
+#define CPM_BUF_SIZE 512
 static char global_buf[BUF_SIZE];
+static char dnscpm_global_buf[CPM_BUF_SIZE];
+static char global_rv_buf[CPM_BUF_SIZE];
+static char compression_buf[CPM_BUF_SIZE];
 
 static int verbose = 0;
 
 static int bidirectional = 0;
 
+static int dnscpm = 0;
+
 #if defined(PACKAGE_STRING)
 static const char *version = PACKAGE_STRING;
 #else
@@ -67,11 +73,16 @@ static const char *default_dns_servers =
 static char *dns_servers = NULL;
 static int dns_servers_len;
 static id_addr_t *dns_server_addrs;
+static int foreign_dns_servers_len;
+static int chn_dns_servers_len;
+static id_addr_t *chn_dns_server_addrs;
+static id_addr_t *foreign_dns_server_addrs;
 
 static int parse_args(int argc, char **argv);
 
 static int setnonblock(int sock);
 static int resolve_dns_servers();
+static int resolve_dnscpm_servers();
 
 static const char *default_listen_addr = "0.0.0.0";
 static const char *default_listen_port = "53";
@@ -91,10 +102,13 @@ static int test_ip_in_list(struct in_add
 
 static int dns_init_sockets();
 static void dns_handle_local();
+static void dnscpm_handle_local();
 static void dns_handle_remote();
+static void dnscpm_handle_remote();
 
 static const char *hostname_from_question(ns_msg msg);
 static int should_filter_query(ns_msg msg, struct in_addr dns_addr);
+static int dnscpm_should_filter_query(ns_msg msg, struct in_addr dns_addr);
 
 static void queue_add(id_addr_t id_addr);
 static id_addr_t *queue_lookup(uint16_t id);
@@ -188,8 +202,13 @@ int main(int argc, char **argv) {
     return EXIT_FAILURE;
   if (0 != parse_chnroute())
     return EXIT_FAILURE;
-  if (0 != resolve_dns_servers())
-    return EXIT_FAILURE;
+  if (0 != dnscpm) {
+  	if (0 != resolve_dnscpm_servers())
+    	return EXIT_FAILURE;
+  }else{
+  	if (0 != resolve_dns_servers())
+    	return EXIT_FAILURE;
+  }
   if (0 != dns_init_sockets())
     return EXIT_FAILURE;
 
@@ -210,7 +229,9 @@ int main(int argc, char **argv) {
       ERR("select");
       return EXIT_FAILURE;
     }
-    check_and_send_delay();
+    if (0 == dnscpm) {
+    	check_and_send_delay();
+    }
     if (FD_ISSET(local_sock, &errorset)) {
       // TODO getsockopt(..., SO_ERROR, ...);
       VERR("local_sock error\n");
@@ -222,9 +243,17 @@ int main(int argc, char **argv) {
       return EXIT_FAILURE;
     }
     if (FD_ISSET(local_sock, &readset))
-      dns_handle_local();
+      if (0 != dnscpm) {
+	  	dnscpm_handle_local();
+	  }else{
+	  	dns_handle_local();
+	  }
     if (FD_ISSET(remote_sock, &readset))
-      dns_handle_remote();
+      if (0 != dnscpm) {
+	  	dnscpm_handle_remote();
+	  }else{
+	  	dns_handle_remote();
+	  }
   }
   return EXIT_SUCCESS;
 }
@@ -249,7 +278,7 @@ static int parse_args(int argc, char **a
   ip_list_file = strdup(default_ip_list_file);
   listen_addr = strdup(default_listen_addr);
   listen_port = strdup(default_listen_port);
-  while ((ch = getopt(argc, argv, "hb:p:s:l:c:y:dv")) != -1) {
+  while ((ch = getopt(argc, argv, "hb:p:s:l:c:y:d:zv")) != -1) {
     switch (ch) {
     case 'h':
       printf("%s", help_message);
@@ -275,6 +304,9 @@ static int parse_args(int argc, char **a
     case 'd':
       bidirectional = 1;
       break;
+    case 'z':
+      dnscpm = 1;
+      break;
     case 'v':
       verbose = 1;
       break;
@@ -288,6 +320,60 @@ static int parse_args(int argc, char **a
   return 0;
 }
 
+static int resolve_dnscpm_servers() {
+  struct addrinfo hints;
+  struct addrinfo *addr_ip;
+  char* token;
+  int r;
+  char *pch = strchr(dns_servers, ',');
+  chn_dns_servers_len = 0;
+  foreign_dns_servers_len = 0;
+  foreign_dns_server_addrs = calloc(1, sizeof(id_addr_t));
+  chn_dns_server_addrs = calloc(1, sizeof(id_addr_t));
+
+  memset(&hints, 0, sizeof(hints));
+  hints.ai_family = AF_INET;
+  hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */
+  token = strtok(dns_servers, ",");
+  while (token) {
+    char *port;
+    memset(dnscpm_global_buf, 0, CPM_BUF_SIZE);
+    strncpy(dnscpm_global_buf, token, CPM_BUF_SIZE - 1);
+    port = (strrchr(dnscpm_global_buf, ':'));
+    if (port) {
+      *port = '\0';
+      port++;
+    } else {
+      port = "53";
+    }
+    if (0 != (r = getaddrinfo(dnscpm_global_buf, port, &hints, &addr_ip))) {
+      VERR("%s:%s\n", gai_strerror(r), token);
+      return -1;
+    }
+    token = strtok(0, ",");
+    if (test_ip_in_list(((struct sockaddr_in *)addr_ip->ai_addr)->sin_addr,
+                        &chnroute_list)) {
+      chn_dns_server_addrs[chn_dns_servers_len].addr = addr_ip->ai_addr;
+      chn_dns_server_addrs[chn_dns_servers_len].addrlen = addr_ip->ai_addrlen;
+      chn_dns_servers_len += 1;
+      chn_dns_server_addrs = realloc(chn_dns_server_addrs, (chn_dns_servers_len+1) * sizeof(id_addr_t));
+    } else {
+      foreign_dns_server_addrs[foreign_dns_servers_len].addr = addr_ip->ai_addr;
+      foreign_dns_server_addrs[foreign_dns_servers_len].addrlen = addr_ip->ai_addrlen;
+      foreign_dns_servers_len += 1;
+      foreign_dns_server_addrs = realloc(foreign_dns_server_addrs, (foreign_dns_servers_len+1) * sizeof(id_addr_t));
+    }
+  }
+  if (chnroute_file) {
+    if (!(chn_dns_servers_len && foreign_dns_servers_len)) {
+      VERR("You should have at least one Chinese DNS and one foreign DNS when "
+          "chnroutes is enabled\n");
+      return -1;
+    }
+  }
+  return 0;
+}
+
 static int resolve_dns_servers() {
   struct addrinfo hints;
   struct addrinfo *addr_ip;
@@ -524,6 +610,73 @@ static int dns_init_sockets() {
   return 0;
 }
 
+static void dnscpm_handle_local() {
+  struct sockaddr *src_addr = malloc(sizeof(struct sockaddr));
+  socklen_t src_addrlen = sizeof(struct sockaddr);
+  uint16_t query_id;
+  ssize_t len;
+  int i;
+  const char *question_hostname;
+  ns_msg msg;
+  len = recvfrom(local_sock, dnscpm_global_buf, CPM_BUF_SIZE, 0, src_addr, &src_addrlen);
+  if (len > 0) {
+    if (ns_initparse((const u_char *)dnscpm_global_buf, len, &msg) < 0) {
+      ERR("ns_initparse");
+      free(src_addr);
+      return;
+    }
+    // parse DNS query id
+    // TODO generate id for each request to avoid conflicts
+    query_id = ns_msg_id(msg);
+    question_hostname = hostname_from_question(msg);
+    LOG("request %s\n", question_hostname);
+    id_addr_t id_addr;
+    id_addr.id = query_id;
+    id_addr.addr = src_addr;
+    id_addr.addrlen = src_addrlen;
+    queue_add(id_addr);
+    //use compression pointer for foreign dns
+    if (len > 16){
+      size_t off = 12;
+      int ended = 0;
+      while (off < len - 4){
+        if (dnscpm_global_buf[off] & 0xc0)
+          break;
+        if (dnscpm_global_buf[off] == 0){
+          ended = 1;
+          off ++;
+          break;
+        }
+        off += 1 + dnscpm_global_buf[off];
+      }
+      if (ended) {
+        memcpy(compression_buf, dnscpm_global_buf, off-1);
+        memcpy(compression_buf + off + 1, dnscpm_global_buf + off, len - off);
+        compression_buf[off-1] = '\xc0';
+        compression_buf[off] = '\x04';
+        for (i = 0; i < foreign_dns_servers_len; i++) {
+        	if (-1 == sendto(remote_sock, compression_buf, len + 1, 0,
+                       foreign_dns_server_addrs[i].addr, foreign_dns_server_addrs[i].addrlen))
+                ERR("sendto");
+        }
+      }else{
+      	for (i = 0; i < foreign_dns_servers_len; i++) {
+        	if (-1 == sendto(remote_sock, dnscpm_global_buf, len, 0,
+                       foreign_dns_server_addrs[i].addr, foreign_dns_server_addrs[i].addrlen))
+                ERR("sendto");
+        }
+      }
+    for (i = 0; i < chn_dns_servers_len; i++) {
+      if (-1 == sendto(remote_sock, dnscpm_global_buf, len, 0,
+                       chn_dns_server_addrs[i].addr, chn_dns_server_addrs[i].addrlen))
+        ERR("sendto");
+    }
+    }
+  }
+  else
+    ERR("recvfrom");
+}
+
 static void dns_handle_local() {
   struct sockaddr *src_addr = malloc(sizeof(struct sockaddr));
   socklen_t src_addrlen = sizeof(struct sockaddr);
@@ -559,6 +712,53 @@ static void dns_handle_local() {
     ERR("recvfrom");
 }
 
+static void dnscpm_handle_remote() {
+  struct sockaddr *src_addr = malloc(sizeof(struct sockaddr));
+  socklen_t src_len = sizeof(struct sockaddr);
+  uint16_t query_id;
+  ssize_t len;
+  const char *question_hostname;
+  //int r;
+  ns_msg msg;
+  len = recvfrom(remote_sock, global_rv_buf, CPM_BUF_SIZE, 0, src_addr, &src_len);
+  if (len > 0) {
+    if (ns_initparse((const u_char *)global_rv_buf, len, &msg) < 0) {
+      ERR("ns_initparse");
+      free(src_addr);
+      return;
+    }
+    // parse DNS query id
+    // TODO assign new id instead of using id from clients
+    query_id = ns_msg_id(msg);
+    question_hostname = hostname_from_question(msg);
+    if (question_hostname) {
+      LOG("response %s from %s:%d - ", question_hostname,
+          inet_ntoa(((struct sockaddr_in *)src_addr)->sin_addr),
+          htons(((struct sockaddr_in *)src_addr)->sin_port));
+    }
+    id_addr_t *id_addr = queue_lookup(query_id);
+    if (id_addr) {
+      id_addr->addr->sa_family = AF_INET;
+      if (!dnscpm_should_filter_query(msg, ((struct sockaddr_in *)src_addr)->sin_addr)) {
+        if (verbose)
+          printf("pass\n");
+        if (-1 == sendto(local_sock, global_rv_buf, len, 0, id_addr->addr,
+                        id_addr->addrlen))
+          ERR("sendto");
+      } else {
+        if (verbose)
+          printf("filter\n");
+      }
+    } else {
+      if (verbose)
+        printf("skip\n");
+    }
+    free(src_addr);
+  }
+  else
+    ERR("recvfrom");
+}
+
 static void dns_handle_remote() {
   struct sockaddr *src_addr = malloc(sizeof(struct sockaddr));
   socklen_t src_len = sizeof(struct sockaddr);
@@ -657,6 +857,54 @@ static const char *hostname_from_questio
   return NULL;
 }
 
+static int dnscpm_should_filter_query(ns_msg msg, struct in_addr dns_addr) {
+  ns_rr rr;
+  int rrnum, rrmax;
+  void *r;
+  // TODO cache result for each dns server
+  int dns_is_chn = 0;
+  int i;
+  if (chnroute_file && (foreign_dns_servers_len > 0)) {
+    for (i = 0; i < chn_dns_servers_len; i++){
+       if(dns_addr.s_addr == ((struct sockaddr_in *)chn_dns_server_addrs[i].addr)->sin_addr.s_addr){
+          dns_is_chn = 1;
+          break;
+          }
+    }
+  }
+  rrmax = ns_msg_count(msg, ns_s_an);
+  for (rrnum = 0; rrnum < rrmax; rrnum++) {
+    if (ns_parserr(&msg, ns_s_an, rrnum, &rr)) {
+      ERR("ns_parserr");
+      return 0;
+    }
+    u_int type;
+    const u_char *rd;
+    type = ns_rr_type(rr);
+    rd = ns_rr_rdata(rr);
+    if (type == ns_t_a) {
+      if (verbose)
+        printf("%s, ", inet_ntoa(*(struct in_addr *)rd));
+      if (test_ip_in_list(*(struct in_addr *)rd, &chnroute_list)) {
+        // result is chn
+        if (!dns_is_chn) {
+          if (bidirectional) {
+            // filter DNS result from chn dns if result is outside chn
+            return 1;
+          }
+        }
+      } else {
+        // result is foreign
+        if (dns_is_chn) {
+          // filter DNS result from foreign dns if result is inside chn
+          return 1;
+        }
+      }
+    }
+  }
+  return 0;
+}
+
 static int should_filter_query(ns_msg msg, struct in_addr dns_addr) {
   ns_rr rr;
   int rrnum, rrmax;
